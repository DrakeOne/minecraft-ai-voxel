<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Minecraft AI Voxel - Professional Three.js Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
            position: fixed;
        }
        
        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }
        
        /* HUD */
        .hud {
            position: absolute;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            font-weight: bold;
            pointer-events: none;
            z-index: 10;
        }
        
        #fps {
            top: 10px;
            left: 10px;
            font-size: clamp(12px, 2vw, 14px);
        }
        
        #coords {
            top: 30px;
            left: 10px;
            font-size: clamp(10px, 1.8vw, 12px);
        }
        
        #debug {
            top: 50px;
            left: 10px;
            font-size: clamp(10px, 1.8vw, 12px);
            color: yellow;
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 10;
        }
        
        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: white;
            box-shadow: 0 0 3px rgba(0,0,0,0.8);
        }
        
        #crosshair::before {
            width: 2px;
            height: 20px;
            left: 9px;
        }
        
        #crosshair::after {
            width: 20px;
            height: 2px;
            top: 9px;
        }
        
        /* Mobile Controls */
        .mobile-controls {
            position: fixed;
            display: none;
            touch-action: none;
            z-index: 20;
        }
        
        @media (max-width: 768px), (pointer: coarse) {
            .mobile-controls {
                display: block;
            }
            
            #crosshair {
                display: none;
            }
        }
        
        #joystick {
            bottom: 20px;
            left: 20px;
            width: clamp(100px, 20vw, 120px);
            height: clamp(100px, 20vw, 120px);
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            position: relative;
        }
        
        #joystick-knob {
            position: absolute;
            width: 40%;
            height: 40%;
            background: rgba(255,255,255,0.5);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: none;
        }
        
        .action-buttons {
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: clamp(8px, 2vw, 10px);
            flex-direction: column;
        }
        
        .action-btn {
            width: clamp(50px, 12vw, 60px);
            height: clamp(50px, 12vw, 60px);
            background: rgba(255,255,255,0.2);
            border: 2px solid rgba(255,255,255,0.4);
            border-radius: 50%;
            color: white;
            font-weight: bold;
            font-size: clamp(10px, 2.5vw, 12px);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }
        
        .action-btn:active {
            background: rgba(255,255,255,0.4);
            transform: scale(0.95);
        }
        
        /* Loading Screen */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #1a1a1a;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            z-index: 1000;
        }
        
        #loading h2 {
            font-size: clamp(18px, 4vw, 24px);
            margin-bottom: 20px;
        }
        
        .loading-bar {
            width: min(200px, 80vw);
            height: 4px;
            background: rgba(255,255,255,0.2);
            margin-top: 20px;
            border-radius: 2px;
            overflow: hidden;
        }
        
        .loading-progress {
            height: 100%;
            background: #4CAF50;
            width: 0%;
            transition: width 0.3s ease;
        }
        
        /* Prevent iOS bounce */
        @supports (-webkit-touch-callout: none) {
            body {
                position: fixed;
                width: 100%;
                height: 100%;
            }
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading">
        <h2>Cargando Minecraft AI Voxel...</h2>
        <div class="loading-bar">
            <div class="loading-progress" id="loadingProgress"></div>
        </div>
    </div>

    <!-- Game Canvas -->
    <canvas id="gameCanvas"></canvas>
    
    <!-- HUD Elements -->
    <div id="fps" class="hud">FPS: 0</div>
    <div id="coords" class="hud">X: 0 Y: 0 Z: 0</div>
    <div id="debug" class="hud">Faces: 0</div>
    <div id="crosshair"></div>
    
    <!-- Mobile Controls -->
    <div id="joystick" class="mobile-controls">
        <div id="joystick-knob"></div>
    </div>
    
    <div class="action-buttons mobile-controls">
        <button class="action-btn" id="jumpBtn">JUMP</button>
        <button class="action-btn" id="placeBtn">PLACE</button>
        <button class="action-btn" id="breakBtn">BREAK</button>
    </div>

    <!-- Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // Prevent iOS bounce and ensure proper sizing
        document.addEventListener('gesturestart', e => e.preventDefault());
        document.addEventListener('gesturechange', e => e.preventDefault());
        
        // Performance monitoring
        const stats = {
            fps: 0,
            frameTime: 0,
            lastTime: performance.now(),
            totalFaces: 0
        };

        // Game configuration
        const config = {
            chunkSize: 16,
            renderDistance: 4,
            blockSize: 1,
            gravity: -20,
            jumpVelocity: 10,
            moveSpeed: 5,
            mouseSensitivity: 0.002,
            mobileMoveSensitivity: 0.02
        };

        // Block types
        const BlockType = {
            AIR: 0,
            GRASS: 1,
            DIRT: 2,
            STONE: 3,
            WOOD: 4
        };

        // Block colors (optimized for performance)
        const blockColors = {
            [BlockType.GRASS]: 0x4CAF50,
            [BlockType.DIRT]: 0x8B4513,
            [BlockType.STONE]: 0x808080,
            [BlockType.WOOD]: 0x8B4513
        };

        // Initialize Three.js
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x87CEEB, 10, config.chunkSize * config.renderDistance * 1.5);
        scene.background = new THREE.Color(0x87CEEB);

        // Camera setup
        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(0, 10, 10);

        // Renderer setup with optimizations
        const canvas = document.getElementById('gameCanvas');
        const renderer = new THREE.WebGLRenderer({
            canvas,
            antialias: false,
            powerPreference: "high-performance",
            alpha: false,
            stencil: false,
            depth: true
        });
        
        // Ensure proper sizing
        function updateRendererSize() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            
            renderer.setSize(width, height, false);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
        }
        
        updateRendererSize();

        // Enable backface culling
        renderer.shadowMap.enabled = false;
        renderer.sortObjects = true;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(50, 100, 50);
        scene.add(directionalLight);

        // World management (moved before Chunk for access)
        class World {
            constructor() {
                this.chunks = new Map();
                this.loadedChunks = new Set();
            }

            getChunkKey(x, z) {
                return `${x},${z}`;
            }

            getChunk(x, z) {
                const key = this.getChunkKey(x, z);
                if (!this.chunks.has(key)) {
                    this.chunks.set(key, new Chunk(x, z, this));
                }
                return this.chunks.get(key);
            }

            // Get block from world coordinates (handles cross-chunk queries)
            getBlockAtWorldCoords(worldX, worldY, worldZ) {
                const chunkX = Math.floor(worldX / config.chunkSize);
                const chunkZ = Math.floor(worldZ / config.chunkSize);
                const localX = ((worldX % config.chunkSize) + config.chunkSize) % config.chunkSize;
                const localZ = ((worldZ % config.chunkSize) + config.chunkSize) % config.chunkSize;
                
                const chunk = this.getChunk(chunkX, chunkZ);
                return chunk.getBlock(localX, worldY, localZ);
            }

            updateChunksAroundPlayer(playerX, playerZ) {
                const chunkX = Math.floor(playerX / config.chunkSize);
                const chunkZ = Math.floor(playerZ / config.chunkSize);

                const newLoadedChunks = new Set();

                // Load chunks within render distance
                for (let x = -config.renderDistance; x <= config.renderDistance; x++) {
                    for (let z = -config.renderDistance; z <= config.renderDistance; z++) {
                        const cx = chunkX + x;
                        const cz = chunkZ + z;
                        const key = this.getChunkKey(cx, cz);
                        
                        newLoadedChunks.add(key);
                        
                        if (!this.loadedChunks.has(key)) {
                            const chunk = this.getChunk(cx, cz);
                            chunk.updateMesh();
                        }
                    }
                }

                // Unload chunks outside render distance
                for (const key of this.loadedChunks) {
                    if (!newLoadedChunks.has(key)) {
                        const chunk = this.chunks.get(key);
                        if (chunk && chunk.mesh) {
                            scene.remove(chunk.mesh);
                            chunk.mesh.geometry.dispose();
                            chunk.mesh.material.dispose();
                            chunk.mesh = null;
                        }
                    }
                }

                this.loadedChunks = newLoadedChunks;
            }

            getBlockAt(x, y, z) {
                return this.getBlockAtWorldCoords(Math.floor(x), Math.floor(y), Math.floor(z));
            }

            setBlockAt(x, y, z, type) {
                const worldX = Math.floor(x);
                const worldY = Math.floor(y);
                const worldZ = Math.floor(z);
                
                const chunkX = Math.floor(worldX / config.chunkSize);
                const chunkZ = Math.floor(worldZ / config.chunkSize);
                const localX = ((worldX % config.chunkSize) + config.chunkSize) % config.chunkSize;
                const localZ = ((worldZ % config.chunkSize) + config.chunkSize) % config.chunkSize;
                
                const chunk = this.getChunk(chunkX, chunkZ);
                chunk.setBlock(localX, worldY, localZ, type);
                chunk.updateMesh();
                
                // Update all potentially affected adjacent chunks
                const chunksToUpdate = new Set();
                
                // Check if block is on chunk boundary and update neighbors
                if (localX === 0) chunksToUpdate.add(this.getChunk(chunkX - 1, chunkZ));
                if (localX === config.chunkSize - 1) chunksToUpdate.add(this.getChunk(chunkX + 1, chunkZ));
                if (localZ === 0) chunksToUpdate.add(this.getChunk(chunkX, chunkZ - 1));
                if (localZ === config.chunkSize - 1) chunksToUpdate.add(this.getChunk(chunkX, chunkZ + 1));
                
                // Corner cases
                if (localX === 0 && localZ === 0) chunksToUpdate.add(this.getChunk(chunkX - 1, chunkZ - 1));
                if (localX === 0 && localZ === config.chunkSize - 1) chunksToUpdate.add(this.getChunk(chunkX - 1, chunkZ + 1));
                if (localX === config.chunkSize - 1 && localZ === 0) chunksToUpdate.add(this.getChunk(chunkX + 1, chunkZ - 1));
                if (localX === config.chunkSize - 1 && localZ === config.chunkSize - 1) chunksToUpdate.add(this.getChunk(chunkX + 1, chunkZ + 1));
                
                // Update all affected chunks
                chunksToUpdate.forEach(chunk => {
                    if (chunk && this.loadedChunks.has(this.getChunkKey(chunk.x, chunk.z))) {
                        chunk.updateMesh();
                    }
                });
            }
        }

        // Chunk management
        class Chunk {
            constructor(x, z, world) {
                this.x = x;
                this.z = z;
                this.world = world;
                this.blocks = new Uint8Array(config.chunkSize * config.chunkSize * config.chunkSize);
                this.mesh = null;
                this.needsUpdate = true;
                this.generateTerrain();
            }

            generateTerrain() {
                // Simple flat world generation with some variety
                for (let x = 0; x < config.chunkSize; x++) {
                    for (let z = 0; z < config.chunkSize; z++) {
                        const worldX = this.x * config.chunkSize + x;
                        const worldZ = this.z * config.chunkSize + z;
                        
                        // Generate flat terrain at y=0
                        this.setBlock(x, 0, z, BlockType.GRASS);
                        
                        // Add some random blocks for variety
                        if (Math.random() < 0.02) {
                            const height = Math.floor(Math.random() * 3) + 1;
                            for (let y = 1; y <= height; y++) {
                                this.setBlock(x, y, z, BlockType.STONE);
                            }
                        }
                        
                        // Add some underground layers
                        for (let y = -1; y >= -3; y--) {
                            this.setBlock(x, y, z, BlockType.DIRT);
                        }
                        for (let y = -4; y >= -10; y--) {
                            this.setBlock(x, y, z, BlockType.STONE);
                        }
                    }
                }
            }

            getBlock(x, y, z) {
                if (x < 0 || x >= config.chunkSize || 
                    y < -10 || y >= config.chunkSize || 
                    z < 0 || z >= config.chunkSize) {
                    return BlockType.AIR;
                }
                
                // Adjust y to handle negative values
                const adjustedY = y + 10;
                const index = x + adjustedY * config.chunkSize + z * config.chunkSize * (config.chunkSize + 10);
                
                if (index < 0 || index >= this.blocks.length) {
                    return BlockType.AIR;
                }
                
                return this.blocks[index];
            }

            setBlock(x, y, z, type) {
                if (x < 0 || x >= config.chunkSize || 
                    y < -10 || y >= config.chunkSize || 
                    z < 0 || z >= config.chunkSize) {
                    return;
                }
                
                // Adjust y to handle negative values
                const adjustedY = y + 10;
                const index = x + adjustedY * config.chunkSize + z * config.chunkSize * (config.chunkSize + 10);
                
                if (index >= 0 && index < this.blocks.length) {
                    this.blocks[index] = type;
                    this.needsUpdate = true;
                }
            }

            // Check if a face should be rendered by checking adjacent block
            shouldRenderFace(localX, localY, localZ, dir) {
                const checkX = localX + dir[0];
                const checkY = localY + dir[1];
                const checkZ = localZ + dir[2];
                
                // If checking within chunk bounds
                if (checkX >= 0 && checkX < config.chunkSize &&
                    checkY >= -10 && checkY < config.chunkSize &&
                    checkZ >= 0 && checkZ < config.chunkSize) {
                    return this.getBlock(checkX, checkY, checkZ) === BlockType.AIR;
                }
                
                // If checking outside chunk bounds, check neighboring chunk
                const worldX = this.x * config.chunkSize + checkX;
                const worldY = checkY;
                const worldZ = this.z * config.chunkSize + checkZ;
                
                return this.world.getBlockAtWorldCoords(worldX, worldY, worldZ) === BlockType.AIR;
            }

            updateMesh() {
                if (!this.needsUpdate) return;

                // Remove old mesh
                if (this.mesh) {
                    scene.remove(this.mesh);
                    this.mesh.geometry.dispose();
                    this.mesh.material.dispose();
                }

                // Create optimized merged geometry
                const geometry = new THREE.BufferGeometry();
                const vertices = [];
                const normals = [];
                const colors = [];
                const indices = [];
                let vertexCount = 0;
                let faceCount = 0;

                // Generate visible faces only (culling)
                for (let x = 0; x < config.chunkSize; x++) {
                    for (let y = -10; y < config.chunkSize; y++) {
                        for (let z = 0; z < config.chunkSize; z++) {
                            const block = this.getBlock(x, y, z);
                            if (block === BlockType.AIR) continue;

                            const worldX = this.x * config.chunkSize + x;
                            const worldY = y;
                            const worldZ = this.z * config.chunkSize + z;

                            // Check each face for visibility
                            const faces = [
                                { dir: [0, 1, 0], name: 'top' },
                                { dir: [0, -1, 0], name: 'bottom' },
                                { dir: [1, 0, 0], name: 'right' },
                                { dir: [-1, 0, 0], name: 'left' },
                                { dir: [0, 0, 1], name: 'front' },
                                { dir: [0, 0, -1], name: 'back' }
                            ];

                            const color = new THREE.Color(blockColors[block]);

                            faces.forEach(face => {
                                if (this.shouldRenderFace(x, y, z, face.dir)) {
                                    const startVertex = vertexCount;
                                    this.addFace(vertices, normals, colors, worldX, worldY, worldZ, face.dir, face.name, color);
                                    
                                    // Add indices for the face (2 triangles with correct winding)
                                    indices.push(
                                        startVertex, startVertex + 1, startVertex + 2,
                                        startVertex, startVertex + 2, startVertex + 3
                                    );
                                    
                                    vertexCount += 4;
                                    faceCount++;
                                }
                            });
                        }
                    }
                }

                // Update face counter
                stats.totalFaces = faceCount;

                // Set geometry attributes
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                geometry.setIndex(indices);
                
                // Compute bounding box for frustum culling
                geometry.computeBoundingBox();
                geometry.computeBoundingSphere();

                // Create mesh with proper material settings
                const material = new THREE.MeshLambertMaterial({ 
                    vertexColors: true,
                    side: THREE.FrontSide, // Only render front faces
                    flatShading: true
                });

                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.matrixAutoUpdate = false;
                this.mesh.updateMatrix();
                scene.add(this.mesh);

                this.needsUpdate = false;
            }

            addFace(vertices, normals, colors, x, y, z, dir, faceName, color) {
                const half = config.blockSize / 2;

                // Face vertices with correct winding order for backface culling
                let faceVertices;
                if (faceName === 'top') {
                    faceVertices = [
                        [x - half, y + half, z - half],
                        [x + half, y + half, z - half],
                        [x + half, y + half, z + half],
                        [x - half, y + half, z + half]
                    ];
                } else if (faceName === 'bottom') {
                    faceVertices = [
                        [x - half, y - half, z - half],
                        [x - half, y - half, z + half],
                        [x + half, y - half, z + half],
                        [x + half, y - half, z - half]
                    ];
                } else if (faceName === 'right') {
                    faceVertices = [
                        [x + half, y - half, z - half],
                        [x + half, y - half, z + half],
                        [x + half, y + half, z + half],
                        [x + half, y + half, z - half]
                    ];
                } else if (faceName === 'left') {
                    faceVertices = [
                        [x - half, y - half, z + half],
                        [x - half, y - half, z - half],
                        [x - half, y + half, z - half],
                        [x - half, y + half, z + half]
                    ];
                } else if (faceName === 'front') {
                    faceVertices = [
                        [x - half, y - half, z + half],
                        [x + half, y - half, z + half],
                        [x + half, y + half, z + half],
                        [x - half, y + half, z + half]
                    ];
                } else if (faceName === 'back') {
                    faceVertices = [
                        [x + half, y - half, z - half],
                        [x - half, y - half, z - half],
                        [x - half, y + half, z - half],
                        [x + half, y + half, z - half]
                    ];
                }

                // Add vertices for the face
                faceVertices.forEach(vertex => {
                    vertices.push(...vertex);
                    normals.push(...dir);
                    colors.push(color.r, color.g, color.b);
                });
            }
        }

        // Initialize world
        const world = new World();

        // Player controller
        class Player {
            constructor() {
                this.position = new THREE.Vector3(0, 5, 0);
                this.velocity = new THREE.Vector3(0, 0, 0);
                this.rotation = new THREE.Euler(0, 0, 0, 'YXZ');
                this.isGrounded = false;
                this.height = 1.8;
                this.radius = 0.3;
            }

            update(deltaTime, world) {
                // Apply gravity
                if (!this.isGrounded) {
                    this.velocity.y += config.gravity * deltaTime;
                }

                // Update position
                const newPos = this.position.clone().add(
                    this.velocity.clone().multiplyScalar(deltaTime)
                );

                // Simple collision detection
                const groundY = this.checkGround(world, newPos.x, newPos.z);
                if (newPos.y <= groundY + this.height) {
                    newPos.y = groundY + this.height;
                    this.velocity.y = 0;
                    this.isGrounded = true;
                } else {
                    this.isGrounded = false;
                }

                this.position.copy(newPos);

                // Update camera
                camera.position.copy(this.position);
                camera.rotation.copy(this.rotation);
            }

            checkGround(world, x, z) {
                // Check blocks below player
                for (let y = Math.floor(this.position.y); y >= -10; y--) {
                    if (world.getBlockAt(Math.floor(x), y, Math.floor(z)) !== BlockType.AIR) {
                        return y + 0.5;
                    }
                }
                return -10;
            }

            jump() {
                if (this.isGrounded) {
                    this.velocity.y = config.jumpVelocity;
                    this.isGrounded = false;
                }
            }

            move(forward, right) {
                const moveVector = new THREE.Vector3();
                
                // Calculate movement direction
                const forwardVector = new THREE.Vector3(0, 0, -1);
                forwardVector.applyQuaternion(camera.quaternion);
                forwardVector.y = 0;
                forwardVector.normalize();

                const rightVector = new THREE.Vector3(1, 0, 0);
                rightVector.applyQuaternion(camera.quaternion);
                rightVector.y = 0;
                rightVector.normalize();

                moveVector.add(forwardVector.multiplyScalar(forward));
                moveVector.add(rightVector.multiplyScalar(right));

                if (moveVector.length() > 0) {
                    moveVector.normalize();
                    this.velocity.x = moveVector.x * config.moveSpeed;
                    this.velocity.z = moveVector.z * config.moveSpeed;
                } else {
                    this.velocity.x = 0;
                    this.velocity.z = 0;
                }
            }
        }

        // Input handling
        class InputHandler {
            constructor() {
                this.keys = {};
                this.mouseMovement = { x: 0, y: 0 };
                this.touches = new Map();
                this.joystickActive = false;
                this.joystickVector = { x: 0, y: 0 };

                this.setupKeyboard();
                this.setupMouse();
                this.setupTouch();
                this.setupMobileControls();
            }

            setupKeyboard() {
                document.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                });

                document.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });
            }

            setupMouse() {
                canvas.addEventListener('click', () => {
                    canvas.requestPointerLock();
                });

                document.addEventListener('mousemove', (e) => {
                    if (document.pointerLockElement === canvas) {
                        this.mouseMovement.x += e.movementX;
                        this.mouseMovement.y += e.movementY;
                    }
                });

                canvas.addEventListener('mousedown', (e) => {
                    if (document.pointerLockElement === canvas) {
                        if (e.button === 0) this.breakBlock();
                        if (e.button === 2) this.placeBlock();
                    }
                });

                canvas.addEventListener('contextmenu', (e) => e.preventDefault());
            }

            setupTouch() {
                let lastTouchX = 0;
                let lastTouchY = 0;

                canvas.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 1) {
                        lastTouchX = e.touches[0].clientX;
                        lastTouchY = e.touches[0].clientY;
                    }
                });

                canvas.addEventListener('touchmove', (e) => {
                    if (e.touches.length === 1) {
                        const touch = e.touches[0];
                        const deltaX = touch.clientX - lastTouchX;
                        const deltaY = touch.clientY - lastTouchY;

                        this.mouseMovement.x += deltaX * 2;
                        this.mouseMovement.y += deltaY * 2;

                        lastTouchX = touch.clientX;
                        lastTouchY = touch.clientY;
                    }
                    e.preventDefault();
                }, { passive: false });
            }

            setupMobileControls() {
                // Joystick
                const joystick = document.getElementById('joystick');
                const joystickKnob = document.getElementById('joystick-knob');

                const handleJoystick = (e) => {
                    const touch = e.touches[0];
                    const rect = joystick.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    
                    let deltaX = touch.clientX - centerX;
                    let deltaY = touch.clientY - centerY;
                    
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    const maxDistance = rect.width / 2 - 20;
                    
                    if (distance > maxDistance) {
                        deltaX = (deltaX / distance) * maxDistance;
                        deltaY = (deltaY / distance) * maxDistance;
                    }
                    
                    joystickKnob.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;
                    
                    this.joystickVector.x = deltaX / maxDistance;
                    this.joystickVector.y = -deltaY / maxDistance;
                    this.joystickActive = true;
                };

                joystick.addEventListener('touchstart', (e) => {
                    handleJoystick(e);
                    e.preventDefault();
                });

                joystick.addEventListener('touchmove', (e) => {
                    handleJoystick(e);
                    e.preventDefault();
                });

                joystick.addEventListener('touchend', () => {
                    joystickKnob.style.transform = 'translate(-50%, -50%)';
                    this.joystickVector.x = 0;
                    this.joystickVector.y = 0;
                    this.joystickActive = false;
                });

                // Action buttons
                document.getElementById('jumpBtn').addEventListener('touchstart', (e) => {
                    player.jump();
                    e.preventDefault();
                });

                document.getElementById('placeBtn').addEventListener('touchstart', (e) => {
                    this.placeBlock();
                    e.preventDefault();
                });

                document.getElementById('breakBtn').addEventListener('touchstart', (e) => {
                    this.breakBlock();
                    e.preventDefault();
                });
            }

            breakBlock() {
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                
                const intersects = [];
                world.loadedChunks.forEach(key => {
                    const chunk = world.chunks.get(key);
                    if (chunk && chunk.mesh) {
                        const chunkIntersects = raycaster.intersectObject(chunk.mesh);
                        intersects.push(...chunkIntersects);
                    }
                });

                if (intersects.length > 0) {
                    const hit = intersects[0];
                    const point = hit.point.sub(hit.face.normal.multiplyScalar(0.1));
                    world.setBlockAt(
                        Math.floor(point.x + 0.5),
                        Math.floor(point.y + 0.5),
                        Math.floor(point.z + 0.5),
                        BlockType.AIR
                    );
                }
            }

            placeBlock() {
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                
                const intersects = [];
                world.loadedChunks.forEach(key => {
                    const chunk = world.chunks.get(key);
                    if (chunk && chunk.mesh) {
                        const chunkIntersects = raycaster.intersectObject(chunk.mesh);
                        intersects.push(...chunkIntersects);
                    }
                });

                if (intersects.length > 0) {
                    const hit = intersects[0];
                    const point = hit.point.add(hit.face.normal.multiplyScalar(0.1));
                    world.setBlockAt(
                        Math.floor(point.x + 0.5),
                        Math.floor(point.y + 0.5),
                        Math.floor(point.z + 0.5),
                        BlockType.STONE
                    );
                }
            }

            getMovement() {
                let forward = 0;
                let right = 0;

                // Keyboard input
                if (this.keys['KeyW'] || this.keys['ArrowUp']) forward += 1;
                if (this.keys['KeyS'] || this.keys['ArrowDown']) forward -= 1;
                if (this.keys['KeyD'] || this.keys['ArrowRight']) right += 1;
                if (this.keys['KeyA'] || this.keys['ArrowLeft']) right -= 1;

                // Joystick input
                if (this.joystickActive) {
                    forward += this.joystickVector.y;
                    right += this.joystickVector.x;
                }

                return { forward, right };
            }

            consumeMouseMovement() {
                const movement = { ...this.mouseMovement };
                this.mouseMovement.x = 0;
                this.mouseMovement.y = 0;
                return movement;
            }
        }

        // Initialize game objects
        const player = new Player();
        const input = new InputHandler();

        // Game loop
        let lastTime = performance.now();

        function animate() {
            requestAnimationFrame(animate);

            const currentTime = performance.now();
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;

            // Update FPS counter
            stats.fps = Math.round(1 / deltaTime);
            document.getElementById('fps').textContent = `FPS: ${stats.fps}`;

            // Update face counter
            let totalFaces = 0;
            world.loadedChunks.forEach(key => {
                const chunk = world.chunks.get(key);
                if (chunk && chunk.mesh) {
                    totalFaces += chunk.mesh.geometry.index.count / 3;
                }
            });
            document.getElementById('debug').textContent = `Faces: ${totalFaces}`;

            // Update player rotation from mouse
            const mouseMovement = input.consumeMouseMovement();
            player.rotation.y -= mouseMovement.x * config.mouseSensitivity;
            player.rotation.x -= mouseMovement.y * config.mouseSensitivity;
            player.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, player.rotation.x));

            // Update player movement
            const movement = input.getMovement();
            player.move(movement.forward, movement.right);

            // Handle jump
            if (input.keys['Space']) {
                player.jump();
            }

            // Update player physics
            player.update(deltaTime, world);

            // Update world chunks
            world.updateChunksAroundPlayer(player.position.x, player.position.z);

            // Update coordinates display
            document.getElementById('coords').textContent = 
                `X: ${Math.floor(player.position.x)} Y: ${Math.floor(player.position.y)} Z: ${Math.floor(player.position.z)}`;

            // Render
            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            updateRendererSize();
        });

        // Handle orientation change
        window.addEventListener('orientationchange', () => {
            setTimeout(updateRendererSize, 100);
        });

        // Hide loading screen and start game
        window.addEventListener('load', () => {
            // Ensure proper initial sizing
            updateRendererSize();
            
            setTimeout(() => {
                document.getElementById('loadingProgress').style.width = '100%';
                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                    animate();
                }, 500);
            }, 100);
        });

        // Prevent scrolling on mobile
        document.addEventListener('touchmove', (e) => {
            if (e.target.closest('.mobile-controls')) return;
            e.preventDefault();
        }, { passive: false });

        // Handle visibility change
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                // Pause game logic if needed
            } else {
                lastTime = performance.now(); // Reset delta time
            }
        });
    </script>
</body>
</html>