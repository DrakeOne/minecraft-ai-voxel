<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Minecraft AI Voxel - Professional Three.js Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
            position: fixed;
        }
        
        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }
        
        /* HUD */
        .hud {
            position: absolute;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            font-weight: bold;
            pointer-events: none;
            z-index: 10;
        }
        
        #fps {
            top: 10px;
            left: 10px;
            font-size: clamp(12px, 2vw, 14px);
        }
        
        #coords {
            top: 30px;
            left: 10px;
            font-size: clamp(10px, 1.8vw, 12px);
        }
        
        #debug {
            top: 50px;
            left: 10px;
            font-size: clamp(10px, 1.8vw, 12px);
            color: yellow;
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 10;
        }
        
        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: white;
            box-shadow: 0 0 3px rgba(0,0,0,0.8);
        }
        
        #crosshair::before {
            width: 2px;
            height: 20px;
            left: 9px;
        }
        
        #crosshair::after {
            width: 20px;
            height: 2px;
            top: 9px;
        }
        
        /* Mobile Controls */
        .mobile-controls {
            position: fixed;
            display: none;
            touch-action: none;
            z-index: 20;
        }
        
        @media (max-width: 768px), (pointer: coarse) {
            .mobile-controls {
                display: block;
            }
            
            #crosshair {
                display: none;
            }
        }
        
        #joystick {
            position: fixed;
            bottom: calc(20px + env(safe-area-inset-bottom));
            left: calc(20px + env(safe-area-inset-left));
            width: clamp(100px, 20vw, 120px);
            height: clamp(100px, 20vw, 120px);
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 50%;
        }
        
        #joystick-knob {
            position: absolute;
            width: 40%;
            height: 40%;
            background: rgba(255,255,255,0.5);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: none;
        }
        
        .action-buttons {
            position: fixed;
            bottom: calc(20px + env(safe-area-inset-bottom));
            right: calc(20px + env(safe-area-inset-right));
            display: flex;
            gap: clamp(8px, 2vw, 10px);
            flex-direction: column;
        }
        
        .action-btn {
            width: clamp(50px, 12vw, 60px);
            height: clamp(50px, 12vw, 60px);
            background: rgba(255,255,255,0.2);
            border: 2px solid rgba(255,255,255,0.4);
            border-radius: 50%;
            color: white;
            font-weight: bold;
            font-size: clamp(10px, 2.5vw, 12px);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }
        
        .action-btn:active {
            background: rgba(255,255,255,0.4);
            transform: scale(0.95);
        }
        
        /* Loading Screen */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #1a1a1a;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            z-index: 1000;
        }
        
        #loading h2 {
            font-size: clamp(18px, 4vw, 24px);
            margin-bottom: 20px;
        }
        
        .loading-bar {
            width: min(200px, 80vw);
            height: 4px;
            background: rgba(255,255,255,0.2);
            margin-top: 20px;
            border-radius: 2px;
            overflow: hidden;
        }
        
        .loading-progress {
            height: 100%;
            background: #4CAF50;
            width: 0%;
            transition: width 0.3s ease;
        }
        
        /* Prevent iOS bounce */
        @supports (-webkit-touch-callout: none) {
            body {
                position: fixed;
                width: 100%;
                height: 100%;
            }
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading">
        <h2>Cargando Minecraft AI Voxel...</h2>
        <div class="loading-bar">
            <div class="loading-progress" id="loadingProgress"></div>
        </div>
    </div>

    <!-- Game Canvas -->
    <canvas id="gameCanvas"></canvas>
    
    <!-- HUD Elements -->
    <div id="fps" class="hud">FPS: 0</div>
    <div id="coords" class="hud">X: 0 Y: 0 Z: 0</div>
    <div id="debug" class="hud">Faces: 0</div>
    <div id="crosshair"></div>
    
    <!-- Mobile Controls -->
    <div id="joystick" class="mobile-controls">
        <div id="joystick-knob"></div>
    </div>
    
    <div class="action-buttons mobile-controls">
        <button class="action-btn" id="jumpBtn">JUMP</button>
        <button class="action-btn" id="placeBtn">PLACE</button>
        <button class="action-btn" id="breakBtn">BREAK</button>
    </div>

    <!-- Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // Prevent iOS bounce and ensure proper sizing
        document.addEventListener('gesturestart', e => e.preventDefault());
        document.addEventListener('gesturechange', e => e.preventDefault());
        
        // Performance monitoring
        const stats = {
            fps: 0,
            frameTime: 0,
            lastTime: performance.now(),
            totalFaces: 0
        };

        // Game configuration
        const config = {
            chunkSize: 16,
            renderDistance: 4,
            blockSize: 1,
            gravity: -20,
            jumpVelocity: 10,
            moveSpeed: 5,
            mouseSensitivity: 0.002,
            mobileMoveSensitivity: 0.02
        };

        // Block types
        const BlockType = {
            AIR: 0,
            GRASS: 1,
            DIRT: 2,
            STONE: 3,
            WOOD: 4
        };

        // Block colors (optimized for performance)
        const blockColors = {
            [BlockType.GRASS]: 0x4CAF50,
            [BlockType.DIRT]: 0x8B4513,
            [BlockType.STONE]: 0x808080,
            [BlockType.WOOD]: 0x8B4513
        };

        // Initialize Three.js
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x87CEEB, 10, config.chunkSize * config.renderDistance * 1.5);
        scene.background = new THREE.Color(0x87CEEB);

        // Camera setup
        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(0, 10, 10);

        // Renderer setup with optimizations
        const canvas = document.getElementById('gameCanvas');
        const renderer = new THREE.WebGLRenderer({
            canvas,
            antialias: false,
            powerPreference: "high-performance",
            alpha: false,
            stencil: false,
            depth: true
        });
        
        // Ensure proper sizing
        function updateRendererSize() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            
            renderer.setSize(width, height, false);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
        }
        
        updateRendererSize();

        // Enable backface culling
        renderer.shadowMap.enabled = false;
        renderer.sortObjects = true;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(50, 100, 50);
        scene.add(directionalLight);

        // World management (moved before Chunk for access)
        class World {
            constructor() {
                this.chunks = new Map();
                this.loadedChunks = new Set();
            }

            getChunkKey(x, z) {
                return `${x},${z}`;
            }

            getChunk(x, z) {
                const key = this.getChunkKey(x, z);
                if (!this.chunks.has(key)) {
                    this.chunks.set(key, new Chunk(x, z, this));
                }
                return this.chunks.get(key);
            }

            // Get block from world coordinates (handles cross-chunk queries)
            getBlockAtWorldCoords(worldX, worldY, worldZ) {
                const chunkX = Math.floor(worldX / config.chunkSize);
                const chunkZ = Math.floor(worldZ / config.chunkSize);
                const localX = ((worldX % config.chunkSize) + config.chunkSize) % config.chunkSize;
                const localZ = ((worldZ % config.chunkSize) + config.chunkSize) % config.chunkSize;
                
                const chunk = this.getChunk(chunkX, chunkZ);
                return chunk.getBlock(localX, worldY, localZ);
            }

            updateChunksAroundPlayer(playerX, playerZ) {
                const chunkX = Math.floor(playerX / config.chunkSize);
                const chunkZ = Math.floor(playerZ / config.chunkSize);

                const newLoadedChunks = new Set();

                // Load chunks within render distance
                for (let x = -config.renderDistance; x <= config.renderDistance; x++) {
                    for (let z = -config.renderDistance; z <= config.renderDistance; z++) {
                        const cx = chunkX + x;
                        const cz = chunkZ + z;
                        const key = this.getChunkKey(cx, cz);
                        
                        newLoadedChunks.add(key);
                        
                        if (!this.loadedChunks.has(key)) {
                            const chunk = this.getChunk(cx, cz);
                            chunk.updateMesh();
                        }
                    }
                }

                // Unload chunks outside render distance
                for (const key of this.loadedChunks) {
                    if (!newLoadedChunks.has(key)) {
                        const chunk = this.chunks.get(key);
                        if (chunk && chunk.mesh) {
                            scene.remove(chunk.mesh);
                            chunk.mesh.geometry.dispose();
                            chunk.mesh.material.dispose();
                            chunk.mesh = null;
                        }
                    }
                }

                this.loadedChunks = newLoadedChunks;
            }

            getBlockAt(x, y, z) {
                return this.getBlockAtWorldCoords(Math.floor(x), Math.floor(y), Math.floor(z));
            }

            setBlockAt(x, y, z, type) {
                const worldX = Math.floor(x);
                const worldY = Math.floor(y);
                const worldZ = Math.floor(z);
                
                const chunkX = Math.floor(worldX / config.chunkSize);
                const chunkZ = Math.floor(worldZ / config.chunkSize);
                const localX = ((worldX % config.chunkSize) + config.chunkSize) % config.chunkSize;
                const localZ = ((worldZ % config.chunkSize) + config.chunkSize) % config.chunkSize;
                
                const chunk = this.getChunk(chunkX, chunkZ);
                chunk.setBlock(localX, worldY, localZ, type);
                chunk.updateMesh();
                
                // Update all potentially affected adjacent chunks
                const chunksToUpdate = new Set();
                
                // Check if block is on chunk boundary and update neighbors
                if (localX === 0) chunksToUpdate.add(this.getChunk(chunkX - 1, chunkZ));
                if (localX === config.chunkSize - 1) chunksToUpdate.add(this.getChunk(chunkX + 1, chunkZ));
                if (localZ === 0) chunksToUpdate.add(this.getChunk(chunkX, chunkZ - 1));
                if (localZ === config.chunkSize - 1) chunksToUpdate.add(this.getChunk(chunkX, chunkZ + 1));
                
                // Corner cases
                if (localX === 0 && localZ === 0) chunksToUpdate.add(this.getChunk(chunkX - 1, chunkZ - 1));
                if (localX === 0 && localZ === config.chunkSize - 1) chunksToUpdate.add(this.getChunk(chunkX - 1, chunkZ + 1));
                if (localX === config.chunkSize - 1 && localZ === 0) chunksToUpdate.add(this.getChunk(chunkX + 1, chunkZ - 1));
                if (localX === config.chunkSize - 1 && localZ === config.chunkSize - 1) chunksToUpdate.add(this.getChunk(chunkX + 1, chunkZ + 1));
                
                // Update all affected chunks
                chunksToUpdate.forEach(chunk => {
                    if (chunk && this.loadedChunks.has(this.getChunkKey(chunk.x, chunk.z))) {
                        chunk.updateMesh();
                    }
                });
            }
        }

        // Chunk management
        class Chunk {
            constructor(x, z, world) {
                this.x = x;
                this.z = z;
                this.world = world;
                this.blocks = new Uint8Array(config.chunkSize * config.chunkSize * config.chunkSize);
                this.mesh = null;
                this.needsUpdate = true;
                this.generateTerrain();
            }

            generateTerrain() {
                // Simple flat world generation with some variety
                for (let x = 0; x < config.chunkSize; x++) {
                    for (let z = 0; z < config.chunkSize; z++) {
                        const worldX = this.x * config.chunkSize + x;
                        const worldZ = this.z * config.chunkSize + z;
                        
                        // Generate flat terrain at y=0
                        this.setBlock(x, 0, z, BlockType.GRASS);
                        
                        // Add some random blocks for variety
                        if (Math.random() < 0.02) {
                            const height = Math.floor(Math.random() * 3) + 1;
                            for (let y = 1; y <= height; y++) {
                                this.setBlock(x, y, z, BlockType.STONE);
                            }
                        }
                    }
                }
            }

            getBlock(x, y, z) {
                if (x < 0 || x >= config.chunkSize || 
                    y < 0 || y >= config.chunkSize || 
                    z < 0 || z >= config.chunkSize) {
                    return BlockType.AIR;
                }
                const index = x + y * config.chunkSize + z * config.chunkSize * config.chunkSize;
                return this.blocks[index];
            }

            setBlock(x, y, z, type) {
                if (x < 0 || x >= config.chunkSize || 
                    y < 0 || y >= config.chunkSize || 
                    z < 0 || z >= config.chunkSize) {
                    return;
                }
                const index = x + y * config.chunkSize + z * config.chunkSize * config.chunkSize;
                this.blocks[index] = type;
                this.needsUpdate = true;
            }

            // Check if a face should be rendered by checking adjacent block
            shouldRenderFace(localX, localY, localZ, dir) {
                const checkX = localX + dir[0];
                const checkY = localY + dir[1];
                const checkZ = localZ + dir[2];
                
                // If checking within chunk bounds
                if (checkX >= 0 && checkX < config.chunkSize &&
                    checkY >= 0 && checkY < config.chunkSize &&
                    checkZ >= 0 && checkZ < config.chunkSize) {
                    return this.getBlock(checkX, checkY, checkZ) === BlockType.AIR;
                }
                
                // If checking outside chunk bounds, check neighboring chunk
                const worldX = this.x * config.chunkSize + checkX;
                const worldY = checkY;
                const worldZ = this.z * config.chunkSize + checkZ;
                
                return this.world.getBlockAtWorldCoords(worldX, worldY, worldZ) === BlockType.AIR;
            }

            updateMesh() {
                if (!this.needsUpdate) return;

                // Remove old mesh
                if (this.mesh) {
                    scene.remove(this.mesh);
                    this.mesh.geometry.dispose();
                    this.mesh.material.dispose();
                }

                // Create optimized merged geometry
                const geometry = new THREE.BufferGeometry();
                const vertices = [];
                const normals = [];
                const colors = [];
                const indices = [];
                let vertexCount = 0;
                let faceCount = 0;

                // Generate visible faces only (culling)
                for (let x = 0; x < config.chunkSize; x++) {
                    for (let y = 0; y < config.chunkSize; y++) {
                        for (let z = 0; z < config.chunkSize; z++) {
                            const block = this.getBlock(x, y, z);
                            if (block === BlockType.AIR) continue;

                            const worldX = this.x * config.chunkSize + x;
                            const worldY = y;
                            const worldZ = this.z * config.chunkSize + z;

                            // Check each face for visibility
                            const faces = [
                                { dir: [0, 1, 0], name: 'top' },
                                { dir: [0, -1, 0], name: 'bottom' },
                                { dir: [1, 0, 0], name: 'right' },
                                { dir: [-1, 0, 0], name: 'left' },
                                { dir: [0, 0, 1], name: 'front' },
                                { dir: [0, 0, -1], name: 'back' }
                            ];

                            const color = new THREE.Color(blockColors[block]);

                            faces.forEach(face => {
                                if (this.shouldRenderFace(x, y, z, face.dir)) {
                                    const startVertex = vertexCount;
                                    this.ad
