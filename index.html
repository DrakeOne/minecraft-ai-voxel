<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Minecraft AI Voxel - Professional Three.js Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
            position: fixed;
        }
        
        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }
        
        /* HUD */
        .hud {
            position: absolute;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            font-weight: bold;
            pointer-events: none;
            z-index: 10;
        }
        
        #fps {
            top: 10px;
            left: 10px;
            font-size: clamp(12px, 2vw, 14px);
        }
        
        #coords {
            top: 30px;
            left: 10px;
            font-size: clamp(10px, 1.8vw, 12px);
        }
        
        #debug {
            top: 50px;
            left: 10px;
            font-size: clamp(10px, 1.8vw, 12px);
            color: yellow;
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 10;
        }
        
        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: white;
            box-shadow: 0 0 3px rgba(0,0,0,0.8);
        }
        
        #crosshair::before {
            width: 2px;
            height: 20px;
            left: 9px;
        }
        
        #crosshair::after {
            width: 20px;
            height: 2px;
            top: 9px;
        }
        
        /* Mobile Controls */
        .mobile-controls {
            position: fixed;
            display: none;
            touch-action: none;
            z-index: 20;
        }
        
        @media (max-width: 768px), (pointer: coarse) {
            .mobile-controls {
                display: block;
            }
            
            #crosshair {
                display: none;
            }
        }
        
        #joystick {
            position: fixed;
            bottom: calc(20px + env(safe-area-inset-bottom));
            left: calc(20px + env(safe-area-inset-left));
            width: clamp(100px, 20vw, 120px);
            height: clamp(100px, 20vw, 120px);
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 50%;
        }
        
        #joystick-knob {
            position: absolute;
            width: 40%;
            height: 40%;
            background: rgba(255,255,255,0.5);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: none;
        }
        
        .action-buttons {
            position: fixed;
            bottom: calc(20px + env(safe-area-inset-bottom));
            right: calc(20px + env(safe-area-inset-right));
            display: flex;
            gap: clamp(8px, 2vw, 10px);
            flex-direction: column;
        }
        
        .action-btn {
            width: clamp(50px, 12vw, 60px);
            height: clamp(50px, 12vw, 60px);
            background: rgba(255,255,255,0.2);
            border: 2px solid rgba(255,255,255,0.4);
            border-radius: 50%;
            color: white;
            font-weight: bold;
            font-size: clamp(10px, 2.5vw, 12px);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }
        
        .action-btn:active {
            background: rgba(255,255,255,0.4);
            transform: scale(0.95);
        }
        
        /* Loading Screen */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #1a1a1a;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            z-index: 1000;
        }
        
        #loading h2 {
            font-size: clamp(18px, 4vw, 24px);
            margin-bottom: 20px;
        }
        
        .loading-bar {
            width: min(200px, 80vw);
            height: 4px;
            background: rgba(255,255,255,0.2);
            margin-top: 20px;
            border-radius: 2px;
            overflow: hidden;
        }
        
        .loading-progress {
            height: 100%;
            background: #4CAF50;
            width: 0%;
            transition: width 0.3s ease;
        }
        
        /* Prevent iOS bounce */
        @supports (-webkit-touch-callout: none) {
            body {
                position: fixed;
                width: 100%;
                height: 100%;
            }
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading">
        <h2>Cargando Minecraft AI Voxel...</h2>
        <div class="loading-bar">
            <div class="loading-progress" id="loadingProgress"></div>
        </div>
    </div>

    <!-- Game Canvas -->
    <canvas id="gameCanvas"></canvas>
    
    <!-- HUD Elements -->
    <div id="fps" class="hud">FPS: 0</div>
    <div id="coords" class="hud">X: 0 Y: 0 Z: 0</div>
    <div id="debug" class="hud">Faces: 0 | Chunks: 0/0</div>
    <div id="crosshair"></div>
    
    <!-- Mobile Controls -->
    <div id="joystick" class="mobile-controls">
        <div id="joystick-knob"></div>
    </div>
    
    <div class="action-buttons mobile-controls">
        <button class="action-btn" id="jumpBtn">JUMP</button>
        <button class="action-btn" id="placeBtn">PLACE</button>
        <button class="action-btn" id="breakBtn">BREAK</button>
    </div>

    <!-- Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // Prevent iOS bounce and ensure proper sizing
        document.addEventListener('gesturestart', e => e.preventDefault());
        document.addEventListener('gesturechange', e => e.preventDefault());
        
        // Performance monitoring
        const stats = {
            fps: 0,
            frameTime: 0,
            lastTime: performance.now(),
            totalFaces: 0,
            visibleChunks: 0,
            totalChunks: 0
        };

        // Game configuration
        const config = {
            chunkSize: 16,
            renderDistance: 4,
            blockSize: 1,
            gravity: -20,
            jumpVelocity: 10,
            moveSpeed: 5,
            mouseSensitivity: 0.002,
            mobileMoveSensitivity: 0.02
        };

        // Block types
        const BlockType = {
            AIR: 0,
            GRASS: 1,
            DIRT: 2,
            STONE: 3,
            WOOD: 4
        };

        // Block colors (optimized for performance)
        const blockColors = {
            [BlockType.GRASS]: 0x4CAF50,
            [BlockType.DIRT]: 0x8B4513,
            [BlockType.STONE]: 0x808080,
            [BlockType.WOOD]: 0x8B4513
        };

        // Initialize Three.js
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x87CEEB, 10, config.chunkSize * config.renderDistance * 1.5);
        scene.background = new THREE.Color(0x87CEEB);

        // Camera setup
        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(0, 10, 10);

        // Renderer setup with optimizations
        const canvas = document.getElementById('gameCanvas');
        const renderer = new THREE.WebGLRenderer({
            canvas,
            antialias: false,
            powerPreference: "high-performance",
            alpha: false,
            stencil: false,
            depth: true
        });
        
        // Ensure proper sizing
        function updateRendererSize() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            
            renderer.setSize(width, height, false);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
        }
        
        updateRendererSize();

        // Enable backface culling
        renderer.shadowMap.enabled = false;
        renderer.sortObjects = true;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(50, 100, 50);
        scene.add(directionalLight);

        // Frustum Culling Class - ADDED BEFORE World class
        class FrustumCuller {
            constructor() {
                this.frustum = new THREE.Frustum();
                this.matrix = new THREE.Matrix4();
            }

            update(camera) {
                // Update projection-view matrix
                this.matrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
                this.frustum.setFromProjectionMatrix(this.matrix);
            }

            isChunkVisible(chunkX, chunkZ) {
                // Create bounding box for the chunk with small margin to prevent pop-in
                const min = new THREE.Vector3(
                    chunkX * config.chunkSize - 0.5,
                    -0.5,
                    chunkZ * config.chunkSize - 0.5
                );
                const max = new THREE.Vector3(
                    (chunkX + 1) * config.chunkSize + 0.5,
                    config.chunkSize + 0.5,
                    (chunkZ + 1) * config.chunkSize + 0.5
                );
                
                const box = new THREE.Box3(min, max);
                return this.frustum.intersectsBox(box);
            }
        }

        // World management
        class World {
            constructor() {
                this.chunks = new Map();
                this.loadedChunks = new Set();
                this.frustumCuller = new FrustumCuller(); // ADDED: Frustum culler instance
            }

            getChunkKey(x, z) {
                return `${x},${z}`;
            }

            getChunk(x, z) {
                const key = this.getChunkKey(x, z);
                if (!this.chunks.has(key)) {
                    this.chunks.set(key, new Chunk(x, z, this));
                }
                return this.chunks.get(key);
            }

            // Get block from world coordinates (handles cross-chunk queries)
            getBlockAtWorldCoords(worldX, worldY, worldZ) {
                const chunkX = Math.floor(worldX / config.chunkSize);
                const chunkZ = Math.floor(worldZ / config.chunkSize);
                const localX = ((worldX % config.chunkSize) + config.chunkSize) % config.chunkSize;
                const localZ = ((worldZ % config.chunkSize) + config.chunkSize) % config.chunkSize;
                
                const chunk = this.getChunk(chunkX, chunkZ);
                return chunk.getBlock(localX, worldY, localZ);
            }

            updateChunksAroundPlayer(playerX, playerZ) {
                // ADDED: Update frustum with current camera
                this.frustumCuller.update(camera);
                
                const chunkX = Math.floor(playerX / config.chunkSize);
                const chunkZ = Math.floor(playerZ / config.chunkSize);
                const newLoadedChunks = new Set();

                // Load chunks within render distance
                for (let x = -config.renderDistance; x <= config.renderDistance; x++) {
                    for (let z = -config.renderDistance; z <= config.renderDistance; z++) {
                        const cx = chunkX + x;
                        const cz = chunkZ + z;
                        
                        // ADDED: Check if chunk is visible in frustum
                        if (!this.frustumCuller.isChunkVisible(cx, cz)) {
                            continue; // Skip chunks not visible
                        }
                        
                        const key = this.getChunkKey(cx, cz);
                        newLoadedChunks.add(key);
                        
                        if (!this.loadedChunks.has(key)) {
                            const chunk = this.getChunk(cx, cz);
                            chunk.updateMesh();
                        }
                    }
                }

                // Unload chunks outside render distance or not visible
                for (const key of this.loadedChunks) {
                    if (!newLoadedChunks.has(key)) {
                        const chunk = this.chunks.get(key);
                        if (chunk && chunk.mesh) {
                            scene.remove(chunk.mesh);
                            chunk.mesh.geometry.dispose();
                            chunk.mesh.material.dispose();
                            chunk.mesh = null;
                        }
                    }
                }

                this.loadedChunks = newLoadedChunks;
                
                // ADDED: Update stats for debugging
                stats.visibleChunks = newLoadedChunks.size;
                stats.totalChunks = (config.renderDistance * 2 + 1) * (config.renderDistance * 2 + 1);
            }

            getBlockAt(x, y, z) {
                return this.getBlockAtWorldCoords(Math.floor(x), Math.floor(y), Math.floor(z));
            }

            setBlockAt(x, y, z, type) {
                const worldX = Math.floor(x);
                const worldY = Math.floor(y);
                const worldZ = Math.floor(z);
                
                const chunkX = Math.floor(worldX / config.chunkSize);
                const chunkZ = Math.floor(worldZ / config.chunkSize);
                const localX = ((worldX % config.chunkSize) + config.chunkSize) % config.chunkSize;
                const localZ = ((worldZ % config.chunkSize) + config.chunkSize) % config.chunkSize;
                
                const chunk = this.getChunk(chunkX, chunkZ);
                chunk.setBlock(localX, worldY, localZ, type);
                chunk.updateMesh();
                
                // Update all potentially affected adjacent chunks
                const chunksToUpdate = new Set();
                
                // Check if block is on chunk boundary and update neighbors
                if (localX === 0) chunksToUpdate.add(this.getChunk(chunkX - 1, chunkZ));
                if (localX === config.chunkSize - 1) chunksToUpdate.add(this.getChunk(chunkX + 1, chunkZ));
                if (localZ === 0) chunksToUpdate.add(this.getChunk(chunkX, chunkZ - 1));
                if (localZ === config.chunkSize - 1) chunksToUpdate.add(this.getChunk(chunkX, chunkZ + 1));
                
                // Corner cases
                if (localX === 0 && localZ === 0) chunksToUpdate.add(this.getChunk(chunkX - 1, chunkZ - 1));
                if (localX === 0 && localZ === config.chunkSize - 1) chunksToUpdate.add(this.getChunk(chunkX - 1, chunkZ + 1));
                if (localX === config.chunkSize - 1 && localZ === 0) chunksToUpdate.add(this.getChunk(chunkX + 1, chunkZ - 1));
                if (localX === config.chunkSize - 1 && localZ === config.chunkSize - 1) chunksToUpdate.add(this.getChunk(chunkX + 1, chunkZ + 1));
                
                // Update all affected chunks
                chunksToUpdate.forEach(chunk => {
                    if (chunk && this.loadedChunks.has(this.getChunkKey(chunk.x, chunk.z))) {
                        chunk.updateMesh();
                    }
                });
            }
        }

        // Chunk management
        class Chunk {
            constructor(x, z, world) {
                this.x = x;
                this.z = z;
                this.world = world;
                this.blocks = new Uint8Array(config.chunkSize * config.chunkSize * config.chunkSize);
                this.mesh = null;
                this.needsUpdate = true;
                this.generateTerrain();
            }

            generateTerrain() {
                // Simple flat world generation with some variety
                for (let x = 0; x < config.chunkSize; x++) {
                    for (let z = 0; z < config.chunkSize; z++) {
                        const worldX = this.x * config.chunkSize + x;
                        const worldZ = this.z * config.chunkSize + z;
                        
                        // Generate flat terrain at y=0
                        this.setBlock(x, 0, z, BlockType.GRASS);
                        
                        // Add some random blocks for variety
                        if (Math.random() < 0.02) {
                            const height = Math.floor(Math.random() * 3) + 1;
                            for (let y = 1; y <= height; y++) {
                                this.setBlock(x, y, z, BlockType.STONE);
                            }
                        }
                    }
                }
            }

            getBlock(x, y, z) {
                if (x < 0 || x >= config.chunkSize || 
                    y < 0 || y >= config.chunkSize || 
                    z < 0 || z >= config.chunkSize) {
                    return BlockType.AIR;
                }
                const index = x + y * config.chunkSize + z * config.chunkSize * config.chunkSize;
                return this.blocks[index];
            }

            setBlock(x, y, z, type) {
                if (x < 0 || x >= config.chunkSize || 
                    y < 0 || y >= config.chunkSize || 
                    z < 0 || z >= config.chunkSize) {
                    return;
                }
                const index = x + y * config.chunkSize + z * config.chunkSize * config.chunkSize;
                this.blocks[index] = type;
                this.needsUpdate = true;
            }

            // Check if a face should be rendered by checking adjacent block
            shouldRenderFace(localX, localY, localZ, dir) {
                const checkX = localX + dir[0];
                const checkY = localY + dir[1];
                const checkZ = localZ + dir[2];
                
                // If checking within chunk bounds
                if (checkX >= 0 && checkX < config.chunkSize &&
                    checkY >= 0 && checkY < config.chunkSize &&
                    checkZ >= 0 && checkZ < config.chunkSize) {
                    return this.getBlock(checkX, checkY, checkZ) === BlockType.AIR;
                }
                
                // If checking outside chunk bounds, check neighboring chunk
                const worldX = this.x * config.chunkSize + checkX;
                const worldY = checkY;
                const worldZ = this.z * config.chunkSize + checkZ;
                
                return this.world.getBlockAtWorldCoords(worldX, worldY, worldZ) === BlockType.AIR;
            }

            updateMesh() {
                if (!this.needsUpdate) return;

                // Remove old mesh
                if (this.mesh) {
                    scene.remove(this.mesh);
                    this.mesh.geometry.dispose();
                    this.mesh.material.dispose();
                }

                // Create optimized merged geometry
                const geometry = new THREE.BufferGeometry();
                const vertices = [];
                const normals = [];
                const colors = [];
                const indices = [];
                let vertexCount = 0;
                let faceCount = 0;

                // Generate visible faces only (culling)
                for (let x = 0; x < config.chunkSize; x++) {
                    for (let y = 0; y < config.chunkSize; y++) {
                        for (let z = 0; z < config.chunkSize; z++) {
                            const block = this.getBlock(x, y, z);
                            if (block === BlockType.AIR) continue;

                            const worldX = this.x * config.chunkSize + x;
                            const worldY = y;
                            const worldZ = this.z * config.chunkSize + z;

                            // Check each face for visibility
                            const faces = [
                                { dir: [0, 1, 0], name: 'top' },
                                { dir: [0, -1, 0], name: 'bottom' },
                                { dir: [1, 0, 0], name: 'right' },
                                { dir: [-1, 0, 0], name: 'left' },
                                { dir: [0, 0, 1], name: 'front' },
                                { dir: [0, 0, -1], name: 'back' }
                            ];

                            const color = new THREE.Color(blockColors[block]);

                            faces.forEach(face => {
                                if (this.shouldRenderFace(x, y, z, face.dir)) {
                                    const startVertex = vertexCount;
                                    this.addFace(vertices, normals, colors, indices, worldX, worldY, worldZ, face, color);
                                    vertexCount += 4;
                                    faceCount++;
                                }
                            });
                        }
                    }
                }

                if (vertices.length === 0) {
                    this.needsUpdate = false;
                    return;
                }

                // Set geometry attributes
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                geometry.setIndex(indices);

                // Create mesh with vertex colors
                const material = new THREE.MeshLambertMaterial({ 
                    vertexColors: true,
                    side: THREE.FrontSide
                });
                
                this.mesh = new THREE.Mesh(geometry, material);
                scene.add(this.mesh);

                stats.totalFaces = faceCount;
                this.needsUpdate = false;
            }

            addFace(vertices, normals, colors, indices, x, y, z, face, color) {
                const size = config.blockSize;
                const half = size / 2;

                // Define vertices for each face
                let faceVertices = [];
                let normal = [0, 0, 0];

                switch(face.name) {
                    case 'top':
                        faceVertices = [
                            [x - half, y + half, z - half],
                            [x + half, y + half, z - half],
                            [x + half, y + half, z + half],
                            [x - half, y + half, z + half]
                        ];
                        normal = [0, 1, 0];
                        break;
                    case 'bottom':
                        faceVertices = [
                            [x - half, y - half, z + half],
                            [x + half, y - half, z + half],
                            [x + half, y - half, z - half],
                            [x - half, y - half, z - half]
                        ];
                        normal = [0, -1, 0];
                        break;
                    case 'right':
                        faceVertices = [
                            [x + half, y - half, z - half],
                            [x + half, y - half, z + half],
                            [x + half, y + half, z + half],
                            [x + half, y + half, z - half]
                        ];
                        normal = [1, 0, 0];
                        break;
                    case 'left':
                        faceVertices = [
                            [x - half, y - half, z + half],
                            [x - half, y - half, z - half],
                            [x - half, y + half, z - half],
                            [x - half, y + half, z + half]
                        ];
                        normal = [-1, 0, 0];
                        break;
                    case 'front':
                        faceVertices = [
                            [x - half, y - half, z + half],
                            [x + half, y - half, z + half],
                            [x + half, y + half, z + half],
                            [x - half, y + half, z + half]
                        ];
                        normal = [0, 0, 1];
                        break;
                    case 'back':
                        faceVertices = [
                            [x + half, y - half, z - half],
                            [x - half, y - half, z - half],
                            [x - half, y + half, z - half],
                            [x + half, y + half, z - half]
                        ];
                        normal = [0, 0, -1];
                        break;
                }

                // Add vertices
                const baseIndex = vertices.length / 3;
                faceVertices.forEach(vertex => {
                    vertices.push(...vertex);
                    normals.push(...normal);
                    colors.push(color.r, color.g, color.b);
                });

                // Add indices for two triangles
                indices.push(
                    baseIndex, baseIndex + 1, baseIndex + 2,
                    baseIndex, baseIndex + 2, baseIndex + 3
                );
            }
        }

        // Player controller
        class Player {
            constructor() {
                this.position = new THREE.Vector3(8, 5, 8);
                this.velocity = new THREE.Vector3(0, 0, 0);
                this.rotation = new THREE.Euler(0, 0, 0, 'YXZ');
                this.isGrounded = false;
                this.canJump = true;
            }

            update(deltaTime, input) {
                // Apply gravity
                if (!this.isGrounded) {
                    this.velocity.y += config.gravity * deltaTime;
                }

                // Movement
                const moveVector = new THREE.Vector3();
                
                if (input.forward) moveVector.z -= 1;
                if (input.backward) moveVector.z += 1;
                if (input.left) moveVector.x -= 1;
                if (input.right) moveVector.x += 1;

                if (moveVector.length() > 0) {
                    moveVector.normalize();
                    moveVector.multiplyScalar(config.moveSpeed);
                    
                    // Apply rotation
                    moveVector.applyAxisAngle(new THREE.Vector3(0, 1, 0), this.rotation.y);
                    
                    this.velocity.x = moveVector.x;
                    this.velocity.z = moveVector.z;
                } else {
                    this.velocity.x *= 0.8;
                    this.velocity.z *= 0.8;
                }

                // Jump
                if (input.jump && this.isGrounded && this.canJump) {
                    this.velocity.y = config.jumpVelocity;
                    this.canJump = false;
                }
                
                if (!input.jump) {
                    this.canJump = true;
                }

                // Apply velocity
                const nextPosition = this.position.clone().add(
                    this.velocity.clone().multiplyScalar(deltaTime)
                );

                // Simple collision detection
                const footY = Math.floor(nextPosition.y - 1.5);
                const headY = Math.floor(nextPosition.y + 0.3);
                
                // Check ground collision
                if (this.velocity.y <= 0) {
                    const groundBlock = world.getBlockAt(nextPosition.x, footY, nextPosition.z);
                    if (groundBlock !== BlockType.AIR) {
                        nextPosition.y = footY + 2.5;
                        this.velocity.y = 0;
                        this.isGrounded = true;
                    } else {
                        this.isGrounded = false;
                    }
                }

                // Check ceiling collision
                if (this.velocity.y > 0) {
                    const ceilingBlock = world.getBlockAt(nextPosition.x, headY, nextPosition.z);
                    if (ceilingBlock !== BlockType.AIR) {
                        this.velocity.y = 0;
                    }
                }

                // Update position
                this.position.copy(nextPosition);

                // Update camera
                camera.position.copy(this.position);
                camera.position.y += 0.5;
                camera.rotation.order = 'YXZ';
                camera.rotation.y = this.rotation.y;
                camera.rotation.x = this.rotation.x;
            }
        }

        // Input handling
        class InputHandler {
            constructor() {
                this.keys = {};
                this.mouse = { x: 0, y: 0, locked: false };
                this.touch = { active: false, startX: 0, startY: 0, currentX: 0, currentY: 0 };
                this.joystick = { x: 0, y: 0, active: false };
                
                this.setupEventListeners();
            }

            setupEventListeners() {
                // Keyboard
                document.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });

                // Mouse
                canvas.addEventListener('click', () => {
                    if (!this.mouse.locked && !this.isMobile()) {
                        canvas.requestPointerLock();
                    }
                });

                document.addEventListener('pointerlockchange', () => {
                    this.mouse.locked = document.pointerLockElement === canvas;
                });

                document.addEventListener('mousemove', (e) => {
                    if (this.mouse.locked) {
                        this.mouse.x += e.movementX;
                        this.mouse.y += e.movementY;
                    }
                });

                // Mouse buttons
                canvas.addEventListener('mousedown', (e) => {
                    if (this.mouse.locked) {
                        if (e.button === 0) this.breakBlock();
                        if (e.button === 2) this.placeBlock();
                    }
                });

                canvas.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                });

                // Touch controls
                canvas.addEventListener('touchstart', (e) => {
                    if (!this.joystick.active && e.touches.length === 1) {
                        this.touch.active = true;
                        this.touch.startX = e.touches[0].clientX;
                        this.touch.startY = e.touches[0].clientY;
                        this.touch.currentX = this.touch.startX;
                        this.touch.currentY = this.touch.startY;
                    }
                });

                canvas.addEventListener('touchmove', (e) => {
                    if (this.touch.active && e.touches.length === 1) {
                        e.preventDefault();
                        this.touch.currentX = e.touches[0].clientX;
                        this.touch.currentY = e.touches[0].clientY;
                        
                        const deltaX = this.touch.currentX - this.touch.startX;
                        const deltaY = this.touch.currentY - this.touch.startY;
                        
                        this.mouse.x += deltaX * config.mobileMoveSensitivity;
                        this.mouse.y += deltaY * config.mobileMoveSensitivity;
                        
                        this.touch.startX = this.touch.currentX;
                        this.touch.startY = this.touch.currentY;
                    }
                });

                canvas.addEventListener('touchend', () => {
                    this.touch.active = false;
                });

                // Mobile controls
                this.setupMobileControls();

                // Window resize
                window.addEventListener('resize', updateRendererSize);
            }

            setupMobileControls() {
                // Joystick
                const joystick = document.getElementById('joystick');
                const joystickKnob = document.getElementById('joystick-knob');
                
                const handleJoystick = (e) => {
                    const touch = e.touches[0];
                    const rect = joystick.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    
                    let deltaX = touch.clientX - centerX;
                    let deltaY = touch.clientY - centerY;
                    
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    const maxDistance = rect.width / 2 - 20;
                    
                    if (distance > maxDistance) {
                        deltaX = (deltaX / distance) * maxDistance;
                        deltaY = (deltaY / distance) * maxDistance;
                    }
                    
                    joystickKnob.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;
                    
                    this.joystick.x = deltaX / maxDistance;
                    this.joystick.y = deltaY / maxDistance;
                };

                joystick.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.joystick.active = true;
                    handleJoystick(e);
                });

                joystick.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (this.joystick.active) {
                        handleJoystick(e);
                    }
                });

                joystick.addEventListener('touchend', () => {
                    this.joystick.active = false;
                    this.joystick.x = 0;
                    this.joystick.y = 0;
                    joystickKnob.style.transform = 'translate(-50%, -50%)';
                });

                // Action buttons
                document.getElementById('jumpBtn').addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.keys['Space'] = true;
                });
                
                document.getElementById('jumpBtn').addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.keys['Space'] = false;
                });

                document.getElementById('breakBtn').addEventListener('click', () => {
                    this.breakBlock();
                });

                document.getElementById('placeBtn').addEventListener('click', () => {
                    this.placeBlock();
                });
            }

            getInput() {
                const input = {
                    forward: this.keys['KeyW'] || this.keys['ArrowUp'] || this.joystick.y < -0.3,
                    backward: this.keys['KeyS'] || this.keys['ArrowDown'] || this.joystick.y > 0.3,
                    left: this.keys['KeyA'] || this.keys['ArrowLeft'] || this.joystick.x < -0.3,
                    right: this.keys['KeyD'] || this.keys['ArrowRight'] || this.joystick.x > 0.3,
                    jump: this.keys['Space'],
                    mouseX: this.mouse.x,
                    mouseY: this.mouse.y
                };

                // Apply mouse movement to player rotation
                if (this.mouse.locked || this.touch.active || this.isMobile()) {
                    player.rotation.y -= this.mouse.x * config.mouseSensitivity;
                    player.rotation.x -= this.mouse.y * config.mouseSensitivity;
                    player.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, player.rotation.x));
                    
                    this.mouse.x = 0;
                    this.mouse.y = 0;
                }

                return input;
            }

            breakBlock() {
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                
                const pos = player.position.clone();
                pos.y += 0.5;
                
                for (let i = 0; i < 50; i++) {
                    const checkPos = pos.clone().add(
                        raycaster.ray.direction.clone().multiplyScalar(i * 0.1)
                    );
                    
                    const block = world.getBlockAt(checkPos.x, checkPos.y, checkPos.z);
                    if (block !== BlockType.AIR) {
                        world.setBlockAt(checkPos.x, checkPos.y, checkPos.z, BlockType.AIR);
                        break;
                    }
                }
            }

            placeBlock() {
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                
                const pos = player.position.clone();
                pos.y += 0.5;
                
                let lastEmpty = null;
                
                for (let i = 0; i < 50; i++) {
                    const checkPos = pos.clone().add(
                        raycaster.ray.direction.clone().multiplyScalar(i * 0.1)
                    );
                    
                    const block = world.getBlockAt(checkPos.x, checkPos.y, checkPos.z);
                    
                    if (block === BlockType.AIR) {
                        lastEmpty = checkPos.clone();
                    } else if (lastEmpty) {
                        // Don't place block if it would intersect with player
                        const playerFeet = player.position.y - 1.5;
                        const playerHead = player.position.y + 0.5;
                        const blockY = Math.floor(lastEmpty.y);
                        
                        if (Math.floor(lastEmpty.x) === Math.floor(player.position.x) &&
                            Math.floor(lastEmpty.z) === Math.floor(player.position.z) &&
                            blockY >= playerFeet && blockY <= playerHead) {
                            return;
                        }
                        
                        world.setBlockAt(lastEmpty.x, lastEmpty.y, lastEmpty.z, BlockType.STONE);
                        break;
                    }
                }
            }

            isMobile() {
                return window.matchMedia('(max-width: 768px)').matches || 
                       window.matchMedia('(pointer: coarse)').matches;
            }
        }

        // Initialize game
        const world = new World();
        const player = new Player();
        const inputHandler = new InputHandler();

        // Game loop
        let lastTime = performance.now();
        
        function animate() {
            requestAnimationFrame(animate);
            
            const currentTime = performance.now();
            const deltaTime = Math.min((currentTime - lastTime) / 1000, 0.1);
            lastTime = currentTime;

            // Update FPS counter
            stats.frameTime = currentTime - stats.lastTime;
            stats.fps = Math.round(1000 / stats.frameTime);
            stats.lastTime = currentTime;

            // Update game
            const input = inputHandler.getInput();
            player.update(deltaTime, input);
            world.updateChunksAroundPlayer(player.position.x, player.position.z);

            // Update HUD
            document.getElementById('fps').textContent = `FPS: ${stats.fps}`;
            document.getElementById('coords').textContent = 
                `X: ${Math.floor(player.position.x)} Y: ${Math.floor(player.position.y)} Z: ${Math.floor(player.position.z)}`;
            document.getElementById('debug').textContent = 
                `Faces: ${stats.totalFaces} | Chunks: ${stats.visibleChunks}/${stats.totalChunks}`;

            // Render
            renderer.render(scene, camera);
        }

        // Start game
        window.addEventListener('load', () => {
            // Hide loading screen
            setTimeout(() => {
                document.getElementById('loadingProgress').style.width = '100%';
                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                    animate();
                }, 300);
            }, 100);
        });
    </script>
</body>
</html>